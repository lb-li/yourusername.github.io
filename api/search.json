[{"id":"f3b472985f94ae032ebf7e46f5293bd9","title":"使用 JWTBearer 实现验证授权","content":"使用 JWTBearer 实现验证授权1. NuGet 安装 Microsoft.AspNetCore.Authentication.JwtBearer注意版本兼容，使用 6.X 版本，7.x 版本不兼容 .NET Core 6。\n2. 配置文件json&quot;JwtSettings&quot;: &#123;\n  &quot;Issuer&quot;: &quot;gggk&quot;, // 发行人\n  &quot;Audience&quot;: &quot;audience&quot;, // 受众\n  &quot;SecurityKey&quot;: &quot;gggk20200202kggggggk20200202kggg&quot;, // 安全密钥\n  &quot;ExpireMinutes&quot;: &quot;60&quot; // 过期时效（分钟）\n&#125;3.添加 Extensions 文件夹并在文件夹下添加类 AuthorizationSetup.cscsharpusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.IdentityModel.Tokens;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EFCoreProject.Api\n&#123;\n    public static class AuthorizationSetup\n    &#123;\n        public static void AddAuthorizationSetup(this IServiceCollection services,IConfiguration configuration)\n        &#123;\n            if (services == null) throw new ArgumentNullException(nameof(services));\n\n            // 配置策略授权\n            services.AddAuthorization(o =&gt;\n            &#123;\n                // 添加策略，使用时在方法上标注[Authorize(Policy =&quot;AdminPolicy&quot;)]，就会验证请求token中的ClaimTypes.Role是否包含了Admin\n                o.AddPolicy(&quot;AdminPolicy&quot;, o =&gt;\n                &#123;\n                    //ClaimTypes.Role == Admin\n                    o.RequireRole(&quot;Admin&quot;).Build();\n\n                    //ClaimTypes.Role == Admin 或者 == User\n                    //o.RequireRole(&quot;Admin&quot;,&quot;User&quot;).Build(); \n\n                    //ClaimTypes.Role == Admin 并且 == User ,关于添加多个角色策略，在Login控制器中\n                    //o.RequireRole(&quot;Admin&quot;).RequireRole(&quot;User&quot;).Build(); \n                &#125;);\n\n                //只有User的策略\n                o.AddPolicy(&quot;onlyUserPolicy&quot;, o =&gt;\n                &#123;\n                    o.RequireRole(&quot;User&quot;).Build();\n                &#125;);\n\n                //User和Admin都可以访问的策略\n                o.AddPolicy(&quot;UserOrAdminPolicy&quot;, o =&gt;\n                &#123;\n                    o.RequireRole(&quot;User&quot;, &quot;Admin&quot;).Build();\n                &#125;);\n\n                //User并且是Admin才能请求的策略\n                o.AddPolicy(&quot;UserAndAdminPolicy&quot;, o =&gt;\n                &#123;\n                    o.RequireRole(&quot;User&quot;).RequireRole(&quot;Admin&quot;).Build();\n                &#125;);\n            &#125;);\n\n            string key = configuration[&quot;JwtSettings:SecurityKey&quot;];\n            string issuer = configuration[&quot;JwtSettings:Issuer&quot;]; \n            string audience = configuration[&quot;JwtSettings:Audience&quot;];\n                \n\n            SecurityKey securityKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(key)); //秘钥的长度有要求，必须&gt;=16位\n\n            services.AddAuthentication(&quot;Bearer&quot;).AddJwtBearer(o =&gt;\n            &#123;\n                o.TokenValidationParameters = new TokenValidationParameters()\n                &#123;\n                    //是否秘钥认证\n                    ValidateIssuerSigningKey = true,\n                    IssuerSigningKey = securityKey, //秘钥\n\n                    //是否验证发行人\n                    ValidateIssuer = true,\n                    ValidIssuer = issuer, //这个字符串可以随便写，就是发行人\n\n                    //是否验证订阅\n                    ValidateAudience = true,\n                    ValidAudience = audience,\n\n                    //是否验证过期时间\n                    RequireExpirationTime = true,\n                    ValidateLifetime = true,\n                &#125;;\n            &#125;);\n        &#125;\n    &#125;\n&#125;4. 在 Program 类中添加以下代码csharp// 注册 Jwt\nbuilder.Services.AddAuthorizationSetup(builder.Configuration);5. 在 Program 类中添加以下代码csharp// 开启认证\napp.UseAuthentication();\n// 在 app.UseAuthorization(); 之前6. 测试在控制器上添加 [Authorize] 特性类，所在命名空间 using Microsoft.AspNetCore.Authorization;\n7. 添加登录获取 token 的控制器示例如下：\ncsharpusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.IdentityModel.Tokens;\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.Dynamic;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EFCoreProject.API.Controllers\n&#123;\n    [Route(&quot;api/[controller]&quot;)]\n    [ApiController]\n    public class AuthenticationController : ControllerBase\n    &#123;\n        private readonly IConfiguration _configuration;\n\n        public AuthenticationController(IConfiguration configuration) &#123;\n            this._configuration = configuration;\n        &#125;\n\n        [HttpPost]\n        public dynamic Login([FromBody] LoginUser user)\n        &#123;\n\n            dynamic d = new ExpandoObject();\n\n            if (string.IsNullOrWhiteSpace(user.LoginName) || string.IsNullOrWhiteSpace(user.LoginPwd))\n            &#123;\n\n                d.code = -1;\n                d.msg = &quot;账户密码不能为空！&quot;;\n                return d;\n            &#125;\n\n\n            if (user.LoginName == &quot;admin&quot;&amp;&amp; user.LoginPwd==&quot;123&quot;)\n            &#123;\n                //验证通过\n                //返回Token  （票）\n\n                d.code = 1;\n                d.msg = &quot;登录成功！&quot;;\n                d.token = GetJwtToken(&quot;Roles&quot;);\n                return d;\n            &#125;\n            else\n            &#123;\n                d.code = -2;\n                d.msg = &quot;账户或者密码错误！&quot;;\n                return d;\n            &#125;\n        &#125;\n\n\n        /// &lt;summary&gt;\n        /// 颁发令牌接口\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [HttpGet(nameof(GetJwtToken))]\n        public string GetJwtToken(string userRole)\n        &#123;\n            //获取在配置文件中获取Jwt属性设置\n            string key = _configuration[&quot;JwtSettings:SecurityKey&quot;];\n            //Appsettings.app(new string[] &#123; &quot;JwtSettings&quot;, &quot;SecurityKey&quot; &#125;);\n            string issuer = _configuration[&quot;JwtSettings:Issuer&quot;];\n            //Appsettings.app(new string[] &#123; &quot;JwtSettings&quot;, &quot;Issuer&quot; &#125;);\n            string audience = _configuration[&quot;JwtSettings:Audience&quot;];\n            //Appsettings.app(new string[] &#123; &quot;JwtSettings&quot;, &quot;Audience&quot; &#125;);\n            string expireminutes = _configuration[&quot;JwtSettings:ExpireMinutes&quot;];\n\n            //创建授权的token类\n            SecurityToken securityToken = new JwtSecurityToken(\n                issuer: issuer, //签发人\n                audience: audience, //受众\n                signingCredentials: new SigningCredentials(new SymmetricSecurityKey(Encoding.ASCII.GetBytes(key)), SecurityAlgorithms.HmacSha256), //秘钥\n\n                //创建过期时间\n                expires: DateTime.Now.AddMinutes(double.Parse(expireminutes)), //过期时间 \n\n                //自定义JWT字段\n                claims: new Claim[] &#123;\n                    //把模拟请求的角色权限添加到Role中 \n                    new Claim(ClaimTypes.Role,userRole), \n\n                    //下面的都是自定义字段，可以任意添加到Claim作为信息共享\n                    //new Claim(&quot;Name&quot;,&quot;我叫lilili&quot;),\n                    //new Claim(&quot;Age&quot;,&quot;18&quot;),\n                &#125;\n            );\n            //返回请求token\n            //return JsonConvert.SerializeObject(new &#123; token = new JwtSecurityTokenHandler().WriteToken(securityToken) &#125;);\n\n            return new JwtSecurityTokenHandler().WriteToken(securityToken);\n        &#125;\n\n    &#125;\n\n    public class LoginUser &#123;\n        public string LoginName &#123; get; set; &#125;\n        public string LoginPwd &#123; get; set; &#125;\n    &#125;\n&#125;8. 前端调用请求时头部 Authorization: Bearer 空格Token在 axios 请求拦截器中添加请求头：\njavascriptif (sessionStorage.getItem(&quot;token&quot;) != null) &#123;\n    config.headers[&quot;Authorization&quot;] = &#39;Bearer &#39; + sessionStorage.getItem(&quot;token&quot;);\n&#125;\n9.在Swagger中启动JWT认证csharpbuilder.Services.AddSwaggerGen(c =&gt; &#123;\n    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme()\n    &#123;\n        Description = &quot;请输入 token：Authorization:&#123;token&#125;&quot;,\n        Name = &quot;Authorization&quot;,\n        In = ParameterLocation.Header,\n        Type = SecuritySchemeType.ApiKey,\n    &#125;);\n\n    c.AddSecurityRequirement(new OpenApiSecurityRequirement\n    &#123;\n        &#123;\n            new OpenApiSecurityScheme\n            &#123;\n                Reference = new OpenApiReference &#123;\n                    Type = ReferenceType.SecurityScheme,\n                    Id = &quot;Bearer&quot;\n                &#125;\n            &#125;,\n            new string[] &#123; &#125;\n        &#125;\n    &#125;);\n&#125;);","slug":"使用 JWTBearer 实现验证授权","date":"2024-07-19T08:11:35.000Z","categories_index":".NET8 Api框架搭建","tags_index":"JWT,Authorization,.NET Core,ASP.NET","author_index":"小刘"},{"id":"65216184bc16e698eec3cb22c7e46d53","title":"使用 Yarn 创建 Vite + Vue3 + TypeScript 项目","content":"使用 Yarn 创建 Vite + Vue3 + TypeScript 项目1. 创建项目使用以下命令创建一个新的 Vite 项目，并指定使用 Vue 和 TypeScript 模板：\nbashyarn create vite VueDemo -t vue-ts2. 进入项目目录bashcd VueDemo3. 安装依赖bashyarn4. 启动开发服务器bashyarn dev\n5. 项目结构项目创建完成后，目录结构如下：\nbashVueDemo/\n├── node_modules/\n├── public/\n├── src/\n│   ├── assets/\n│   ├── components/\n│   ├── App.vue\n│   ├── main.ts\n│   └── ...\n├── .gitignore\n├── index.html\n├── package.json\n├── tsconfig.json\n├── vite.config.ts\n└── yarn.lock6.运行项目在浏览器中打开 http://localhost:5173 以查看项目运行效果。\n通过以上步骤，你已经成功创建了一个使用 Vite、Vue3 和 TypeScript 的项目。你可以根据需要进一步配置和扩展项目。\n","slug":"使用 Yarn 搭建Vite + Vue3 + TypeScript 项目","date":"2024-07-19T08:11:35.000Z","categories_index":"Vue3项目搭建","tags_index":"Vite,Vue3,TypeScript,Yarn","author_index":"小刘"},{"id":"a5f50b2a48bc0db0066705ce96e653bb","title":"在 Vue 项目中添加 Vue Router","content":"在 Vue 项目中添加 Vue Router1. 安装 Vue Router使用以下命令安装 Vue Router：\nbashyarn add vue-router2. 创建 router 文件夹在 src 目录下创建一个名为 router 的文件夹\n3. 在 router 文件夹中添加 index.ts在 router 文件夹中创建一个 index.ts 文件，并添加以下代码：\ntypescriptimport &#123; createRouter, createWebHistory, RouteRecordRaw &#125; from &quot;vue-router&quot;;\nimport &#123; storeToRefs &#125; from &quot;pinia&quot;\nimport store from &#39;../store/index&#39;\n\n//路由表\nconst routes: Array&lt;RouteRecordRaw&gt; = [\n  &#123;\n    path: &#39;/&#39;,\n    redirect: &#39;/index&#39;\n  &#125;,\n  &#123;\n    path: &#39;/index&#39;,\n    component: () =&gt; import(&#39;../views/system/Index.vue&#39;),\n    children: [\n      &#123;\n        path: &#39;&#39;,\n        component: () =&gt; import(&#39;../views/goods/List.vue&#39;)\n      &#125;,\n      &#123;\n        path: &#39;/goods/list&#39;,\n        component: () =&gt; import(&#39;../views/goods/List.vue&#39;)\n      &#125;\n    ]\n  &#125;,\n  &#123;\n    path: &#39;/login&#39;,\n    component: () =&gt; import(&#39;../views/system/Login.vue&#39;)\n  &#125;\n]\n\n//路由对象\nconst router = createRouter(&#123;\n  routes,\n  history: createWebHistory()\n&#125;)\n\n\n//导航守卫 next()\nrouter.beforeEach((to, from) =&gt; &#123;\n\n  //解构获取 pinia 中的 token\n  const &#123; token &#125; = storeToRefs(store())\n  //let token = localStorage.getItem(&#39;token&#39;);\n  if (token.value.length &gt; 0 || to.path == &#39;/login&#39;)\n    return true;\n  else\n    router.push(&#123; path: &#39;/login&#39; &#125;);\n&#125;)\n\nexport default router;\n4. 在 main.ts 中装载 routertypescriptimport &#123; createApp &#125; from &#39;vue&#39;;\nimport App from &#39;./App.vue&#39;;\nimport Router from &#39;./router/index&#39;;\n\nconst app = createApp(App);\napp.use(Router);\napp.mount(&#39;#app&#39;);\n5. 运行项目确保一切配置正确后，运行以下命令启动开发服务器：\nbashyarn dev","slug":"在 Vue 项目中添加 Vue Router","date":"2024-07-19T08:11:35.000Z","categories_index":"Vue3项目搭建","tags_index":"Yarn,Vue,Vue Router,JavaScript","author_index":"小刘"},{"id":"7bdb8fa9005fbdec4c435a665ce88cc2","title":"通用Result","content":"Result这个可以放在扩展文件夹里\ncsharpnamespace NET8Project.Api\n&#123;\n    public class ResultHandle\n    &#123;\n        public int state &#123; get; set; &#125;\n        public string code &#123; get; set; &#125;\n        public string msg &#123; get; set; &#125;\n    &#125;\n    public class ResultData&lt;T&gt;\n    &#123;\n        public int state &#123; get; set; &#125;\n        public string code &#123; get; set; &#125;\n        public string msg &#123; get; set; &#125;\n        public T data &#123; get; set; &#125;\n    &#125;\n    public class ResultPageList&lt;T&gt;\n    &#123;\n        public int state &#123; get; set; &#125;\n        public string code &#123; get; set; &#125;\n        public string msg &#123; get; set; &#125;\n        public int page &#123; get; set; &#125;\n        public int size &#123; get; set; &#125;\n        public int count &#123; get; set; &#125;\n        public List&lt;T&gt; data &#123; get; set; &#125;\n    &#125;\n&#125;","slug":"通用Result","date":"2024-07-19T08:02:16.977Z","categories_index":".NET8 Api框架搭建","tags_index":".NET,Result","author_index":"小刘"},{"id":"b84c84a24d4fbceb89d7a0429211000c","title":"AutoMapper配置教程","content":"1.NuGet安装  在项目中安装 AutoMapper 包；\n2.添加 AutoMapperConfigs 类到拓展文件夹csharpusing AutoMapper;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing CoreApiProject.Model;\nusing CoreApiProject.DTO;\n\nnamespace CoreApiProject.Api\n&#123;\n    public class AutoMapperConfigs : Profile\n    &#123;\n        //添加你的实体映射关系.\n        public AutoMapperConfigs()\n        &#123;\n            //Entity 转 Dto\n\n            CreateMap&lt;Good, GoodDto&gt;()\n     //属性不一致匹配\n                .ForMember(dest =&gt; dest.TypeName, opt =&gt; opt.MapFrom(src =&gt; src.TidNavigation.Name))\n                //映射发生之前\n                .BeforeMap((source, dto) =&gt;\n                &#123;\n                    //可以较为精确的控制输出数据格式\n                    //dto.CreateTime = Convert.ToDateTime(source.CreateTime).ToString(&quot;yyyy-MM-dd&quot;);\n                    dto.TypeName = source.TidNavigation.Name;\n                &#125;)\n                //映射发生之后\n                .AfterMap((source, dto) =&gt;\n                &#123;\n                    //code ...\n                &#125;)\n                .ReverseMap();\n\n            //UserDto转UserEntity.\n            //CreateMap();\n        &#125;\n    &#125;\n&#125;\n3.在管道中配置 配置Dto 模型映射    builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());\n","slug":"AutoFac配置教程 (2)","date":"2024-07-18T12:04:40.525Z","categories_index":".NET8 Api框架搭建","tags_index":"AutoMapper,.NET,映射","author_index":"小刘"},{"id":"4e5f3f8fca52da9f9ff077c4a363f25c","title":"EFCore配置教程","content":"1. 安装 EFCore 相关安装到Model\n安装 Microsoft.EntityFrameworkCore.SqlServer\n安装 Microsoft.EntityFrameworkCore.Tools\n\n安装到 API\n安装 Microsoft.EntityFrameworkCore.Design\n\n2. 配置连接地址在配置文件中添加连接字符串：\njson&quot;ConnectionStrings&quot;: &#123;\n    &quot;DefaultConnection&quot;: &quot;Data Source=.;Initial Catalog=Book;user id=sa;password=123;Max Pool Size=512;Min Pool Size=5;TrustServerCertificate=true;&quot;\n&#125;3.使用 NuGet 命令 （-F 跟新 ）jsonScaffold-DBContext &quot;Name=ConnectionStrings:DefaultConnection&quot; Microsoft.EntityFrameworkCore.SqlServer -context EFDbContext  -F4.专门注册数据上下文的方法jsonbuilder.Services.AddDbContext&lt;EFDbContext&gt;(options =&gt;\n&#123;\n    var connection = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;);\n    options.UseSqlServer(\n        connection\n    );\n&#125;);","slug":"EFCore配置教程","date":"2024-07-05T00:52:10.000Z","categories_index":".NET8 Api框架搭建","tags_index":".NET,EFCore,数据库","author_index":"小刘"},{"id":"587b43135c6f3485b613ca8a7483ff63","title":"AutoFac配置教程","content":"1. 安装 AutoFac在项目中安装 Autofac.Extensions.DependencyInjection 包：\nbashdotnet add package Autofac.Extensions.DependencyInjection2. 配置类 CustomAutofacModule将配置类 CustomAutofacModule 放入拓展文件夹，并修改程序包名\ncsharpusing Autofac;\nusing System.Reflection;\n\nnamespace NET8Demo.Api\n&#123;\n    public class CustomAutofacModule : Autofac.Module\n    &#123;\n        /// &lt;summary&gt;\n        /// AutoFac注册类\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;builder&quot;&gt;&lt;/param&gt;\n        protected override void Load(ContainerBuilder builder)\n        &#123;\n            List&lt;Type&gt; types = new List&lt;Type&gt;();\n            var svrNames = new string[] &#123; &quot;NET8Demo.Bll&quot;, &quot;NET8Demo.Dal&quot; &#125;;  //程序及名称\n            foreach (string item in svrNames)\n            &#123;\n                // 加载接口服务实现层。\n                Assembly SvrAss = Assembly.Load(item);\n                // 反射扫描这个程序集中所有的类，得到这个程序集中所有类的集合。\n                types.AddRange(SvrAss.GetTypes());\n            &#125;\n            // 告诉AutoFac容器，创建stypes这个集合中所有类的对象实例  在一次Http请求上下文中,共享一个组件实例\n            builder.RegisterTypes(types.ToArray())\n                        .AsImplementedInterfaces().InstancePerLifetimeScope().PropertiesAutowired();\n            //指明创建的stypes这个集合中所有类的对象实例，以其接口的形式保存\n        &#125;\n    &#125;\n&#125;\n3. 在服务管道中注册csharp// 以下是autofac依赖注入\nbuilder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());\nbuilder.Host.ConfigureContainer&lt;ContainerBuilder&gt;(builder =&gt;\n&#123;\n    //批量注册服务  注册模块\n    builder.RegisterModule(new CustomAutofacModule());\n&#125;);","slug":"AutoFac配置教程","date":"2024-07-05T00:52:10.000Z","categories_index":".NET8 Api框架搭建","tags_index":".NET,AutoFac,依赖注入","author_index":"小刘"}]